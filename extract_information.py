#!/usr/bin/env python

"""
Now we're cooking.

This script parses out the important bits from the XML representations
of the SPF PDFs generated by pdf2txt.py (via pdfminer).

We have create separate elementary and middle school maps because --
of course -- the PDFs are slightly different.

Unfortunately we can't use any sort of "clean" XPath that relies on ID
numbers as they change from PDF to PDF. Therefore, we look in the
@bbox attribute for a given set of coordinates.

It ain't pretty, but it works.
"""

import re
import tablib
from lxml import etree

# (xpath, number of digits in the 'Points Possible' column)
es_element_map = {
    "Academic Growth":      (etree.XPath("//page[@id='1']//text[contains(@bbox, '510.359')]/text()"), 2),
    "Academic Growth/Math": (etree.XPath("//page[@id='2']//text[contains(@bbox, '495.359')]/text()"), 2),

    "Academic Achievement": (etree.XPath("//page[@id='1']//text[contains(@bbox, '480.359')]/text()"), 2),
    "Academic Growth Gaps": (etree.XPath("//page[@id='1']//text[contains(@bbox, '450.359')]/text()"), 2),
    "Other Factors":        (etree.XPath("//page[@id='1']//text[contains(@bbox, '420.359')]/text()"), 2),
    "AYP":                  (etree.XPath("//page[@id='1']//text[contains(@bbox, '388.565')]/text()"), 0),
    "Focus Goal":           (etree.XPath("//page[@id='1']//text[contains(@bbox, '355.565')]/text()"), 0),
    "Total Score":          (etree.XPath("//page[@id='1']//textbox[contains(@bbox, '699.4')]//text[@size]/text()"), 0),
}

def clean(raw):
    return ''.join(raw).strip()

def extract_from_pdf(fname, school_type):
    """
    Given a filename path to a PDF, return a dictionary of its
    relevant categories/points.
    """
    doc = etree.parse(fname)
    ret = {'School': re.search('\d\d\d-([^.]+)\.xml$', fname).group(1)}

    if school_type == 'ES':
        ret['Academic Growth']      = clean(doc.xpath("//textbox[@bbox='476.280,510.359,488.405,520.672']//text/text()"))
        ret['Academic Achievement'] = re.sub('[^\d.]', '', clean(doc.xpath("//textbox[@bbox='471.360,478.564,533.751,490.672']//text/text()")))
        ret['Academic Growth Gaps'] = clean(doc.xpath("//textbox[@bbox='479.280,450.359,485.402,460.672']//text/text()"))
        ret['Other Indicators']     = clean(doc.xpath("//textbox[@bbox='476.280,420.359,488.405,430.672']//text/text()"))
        ret['AYP']                  = clean(doc.xpath("//textbox[@bbox='669.000,388.565,682.196,398.150']//text/text()"))
        ret['Focus Goal']           = clean(doc.xpath("//textbox[@bbox='639.960,355.565,714.096,365.150']//text/text()"))
        ret['Total Score']          = clean(doc.xpath("//textbox[@bbox='663.000,313.440,699.454,323.989']//text/text()"))

    elif school_type == 'MS':
        pass

    elif school_type == 'HS':
        pass

    return ret

    # values = [re.search('\d\d\d-([^.]+)\.xml$', fname).group(1)]
    # for title, (xpath, digits) in element_map.iteritems():
    #     raw = xpath(doc)
    #     if digits:
    #         raw = raw[:-digits]

    #     value = ''.join(raw).strip()
    #     if not value:
    #         print "*** Empty value for '%s'" % title
    #         raise SystemExit

    #     values.append(value)
    #     print "%-25s: %s" % (title, value)

def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("input", nargs='+', metavar="XML")
    parser.add_argument("-t", "--school-type")
    parser.add_argument("-o", "--output", default="output.csv")
    args = parser.parse_args()

    for fname in args.input:
        print "Parsing '%s'..." % fname
        info = extract_from_pdf(fname, args.school_type)
        print info

if __name__ == "__main__":
    main()
