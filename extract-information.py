#!/usr/bin/env python

"""
Now we're cooking.

This script parses out the important bits from the XML representations
of the SPF PDFs generated by pdf2txt.py (via pdfminer).

We have create separate elementary and middle school maps because --
of course -- the PDFs are slightly different.

Unfortunately we can't use any sort of "clean" XPath that relies on ID
numbers as they change from PDF to PDF. Therefore, we look in the
@bbox attribute for a given set of coordinates.

It ain't pretty, but it works.
"""

import re
import tablib
import argparse
from lxml import etree

parser = argparse.ArgumentParser()
parser.add_argument("input", nargs='+')
parser.add_argument("-t", "--school-type")
parser.add_argument("-o", "--output", default="output.csv")
args = parser.parse_args()

# (xpath, number of digits in the 'Points Possible' column)
es_element_map = {
    "Academic Growth":      (etree.XPath("//page[@id='1']//text[contains(@bbox, '510.359')]/text()"), 2),
    "Academic Achievement": (etree.XPath("//page[@id='1']//text[contains(@bbox, '480.359')]/text()"), 2),
    "Academic Growth Gaps": (etree.XPath("//page[@id='1']//text[contains(@bbox, '450.359')]/text()"), 2),
    "Other Factors":        (etree.XPath("//page[@id='1']//text[contains(@bbox, '420.359')]/text()"), 2),
    "AYP":                  (etree.XPath("//page[@id='1']//text[contains(@bbox, '388.565')]/text()"), 0),
    "Focus Goal":           (etree.XPath("//page[@id='1']//text[contains(@bbox, '355.565')]/text()"), 0),
    "Total Score":          (etree.XPath("//page[@id='1']//textbox[contains(@bbox, '699.4')]//text[@size]/text()"), 0),
}

ms_element_map = {}

element_map = {'ES': es_element_map,
               'MS': ms_element_map}.get(args.school_type)

output = tablib.Dataset(headers=["School"] + element_map.keys())

for fname in args.input:
    print "Parsing '%s'..." % fname
    doc = etree.parse(fname)
    values = []

    for title, (xpath, digits) in element_map.iteritems():
        raw = xpath(doc)
        if digits:
            raw = raw[:-digits]
        values.append(''.join(raw))

    output.append([fname] + values)

with open(args.output, 'wb') as fp:
    fp.write(output.csv)
